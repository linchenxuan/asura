# AsuraLog - 高性能零分配 Go 日志库设计文档

## 1. 概述

AsuraLog 是一个专为高性能场景设计的结构化、异步 Go 日志库，特别适用于游戏服务器等对性能和延迟要求极高的应用场景。通过零分配 API、异步写入、对象池化和高性能编码器，AsuraLog 最大限度地减少了日志记录对主逻辑的影响。

## 2. 设计思想

### 2.1 核心设计理念

AsuraLog 的设计基于以下几个核心理念：

1. **性能优先**：游戏服务器对延迟和吞吐量有严格要求，日志系统不能成为性能瓶颈
2. **零分配原则**：避免不必要的内存分配，减少 GC 压力
3. **异步处理**：将日志创建与写入分离，确保主逻辑不受 I/O 阻塞影响
4. **结构化输出**：以 JSON 格式输出，便于日志分析和监控
5. **可扩展性**：支持多种输出目标（控制台、文件、网络等）

### 2.2 为什么这样设计

传统的 Go 日志库往往存在以下问题，不适合高并发游戏服务器场景：

1. **内存分配频繁**：使用 `interface{}` 导致大量内存分配和 GC 压力
2. **同步 I/O 阻塞**：直接将日志写入磁盘或网络，阻塞主逻辑
3. **格式化效率低**：使用反射或字符串拼接进行格式化
4. **功能单一**：不支持结构化输出或灵活配置

AsuraLog 针对这些问题进行了专门优化，特别适合以下场景：
- 高并发游戏服务器（登录、战斗、社交等服务）
- 微服务架构中的分布式日志收集
- 对延迟敏感的实时应用

## 3. 架构设计

AsuraLog 采用经典的分层架构，主要包含以下几层：

### 3.1 接口层

提供统一的日志记录接口，包括：
- `Logger` 接口：定义所有日志器必须实现的方法
- 包级别便捷函数：`Debug()`、`Info()`、`Warn()`、`Error()`、`Fatal()`

### 3.2 核心层

包含日志库的核心组件：
- `GameLogger`：主要的日志实现类，处理日志事件的创建和分发
- `LogEvent`：表示单个日志事件，提供链式 API 添加字段
- `Formatter`：高性能 JSON 格式化器

### 3.3 输出层

负责将日志输出到不同目标，实现了 `LogAppender` 接口：
- `ConsoleAppender`：输出到控制台
- `FileAppender`：输出到文件，支持日志轮转

### 3.4 配置层

提供灵活的配置选项：
- `LogCfg`：包含所有配置项，支持热重载

### 3.5 工具层

提供辅助功能：
- 日志级别管理（`Level`）
- 动态日志级别调整（`levelChange`）
- 文件轮转（`rotate.go`）
- 调用者信息获取（`caller.go`）

## 4. 关键组件详解

### 4.1 Logger 接口

`Logger` 接口是整个日志库的基础，定义了所有日志操作的标准方法，包括不同级别的日志记录、配置和扩展功能。

```go
// Logger 接口定义了所有日志器必须实现的方法
type Logger interface {
    // Debug 记录调试级别的日志
    Debug(args ...interface{})
    // Info 记录信息级别的日志
    Info(args ...interface{})
    // Warn 记录警告级别的日志
    Warn(args ...interface{})
    // Error 记录错误级别的日志
    Error(args ...interface{})
    // Fatal 记录致命级别的日志，通常会导致程序退出
    Fatal(args ...interface{})
    // IgnoreCheckLevel 忽略日志级别检查，直接记录
    IgnoreCheckLevel(level Level, args []interface{})
    // GetAppender 获取指定名称的日志追加器
    GetAppender(name string) LogAppender
    // AddAppender 添加日志追加器
    AddAppender(name string, appender LogAppender)
    // OnEventEnd 当日志事件结束时的回调
    OnEventEnd(logger Logger, level Level, args []interface{})
    // GetSharedKey 获取共享的键
    GetSharedKey() string
}
```

### 4.2 GameLogger 实现

`GameLogger` 是 `Logger` 接口的核心实现，提供了完整的日志功能，包括线程安全的并发访问、日志级别检查和日志事件分发。

```go
// GameLogger 实现了线程安全的日志接口
// 支持不同日志级别和调用者信息
type GameLogger struct {
    level       Level
    appenders   map[string]LogAppender
    mutex       sync.RWMutex
    sharedKey   string
}
```

### 4.3 ActorLogger 实现

`ActorLogger` 是一种特殊的日志器，提供了玩家/角色特定的日志记录功能，支持白名单机制。在游戏服务器中，通常用于记录特定玩家或角色的行为日志。

```go
// ActorLogger 提供玩家/角色特定的日志记录功能，支持白名单
type ActorLogger struct {
    logger      Logger
    actorId     string
    name        string
    sharedKey   string
}
```

### 4.4 日志级别

AsuraLog 支持多种日志级别，用于过滤和分类日志信息：

```go
// Level 定义了日志级别类型
type Level uint32

const (
    // TraceLevel 用于最详细的调试信息
    TraceLevel Level = iota
    // DebugLevel 用于调试信息
    DebugLevel
    // InfoLevel 用于一般信息
    InfoLevel
    // WarnLevel 用于警告信息
    WarnLevel
    // ErrorLevel 用于错误信息
    ErrorLevel
    // FatalLevel 用于致命错误信息
    FatalLevel
)
```

### 4.5 日志追加器

`LogAppender` 接口定义了日志输出的标准方式，不同的实现可以将日志输出到控制台、文件、网络等不同目标：

```go
// LogAppender 接口定义了日志追加器的核心方法
type LogAppender interface {
    // Write 写入日志数据
    Write(data []byte) error
    // Refresh 刷新配置或状态
    Refresh()
}
```

## 5. 性能优化设计

AsuraLog 在性能方面做了多项关键优化，使其特别适合游戏服务器等高性能场景：

### 5.1 零内存分配

AsuraLog 避免了不必要的内存分配，尤其是在日志记录的热点路径上。通过使用预分配的缓冲区和对象池，显著减少了 GC 压力。

```go
// 零内存分配的 Time 方法示例
func Time() []byte {
    now := time.Now()
    // 使用预分配的缓冲区
    buffer := timeBufferPool.Get().(*bytes.Buffer)
    buffer.Reset()
    // 直接操作字节数组，避免字符串拼接
    // ...
    timeBufferPool.Put(buffer)
    return timeBytes
}
```

### 5.2 异步写入

日志写入操作被异步处理，确保主逻辑不会被 I/O 操作阻塞：

```go
// 异步写入示例
func (a *FileAppender) Write(data []byte) error {
    // 将日志数据放入通道
    a.queue <- data
    return nil
}

// 工作协程处理写入
func (a *FileAppender) startWorker() {
    go func() {
        for data := range a.queue {
            // 实际的文件写入操作
            a.file.Write(data)
        }
    }()
}
```

### 5.3 对象池化

对于频繁创建的对象（如日志事件、缓冲区），AsuraLog 使用对象池进行复用，减少内存分配和 GC 压力：

```go
// 对象池示例
var logEventPool = sync.Pool{
    New: func() interface{} {
        return &LogEvent{}
    },
}

// 获取日志事件对象
func getLogEvent() *LogEvent {
    return logEventPool.Get().(*LogEvent)
}

// 归还日志事件对象
func putLogEvent(event *LogEvent) {
    event.Reset()
    logEventPool.Put(event)
}
```

### 5.4 高性能格式化

AsuraLog 使用直接字节操作和专门的格式化器，避免了反射和字符串拼接，显著提高了日志格式化的性能：
